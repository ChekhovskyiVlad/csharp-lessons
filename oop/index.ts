// процедурное программирование - обычно с него начинают изучения программирования.
// ожидается на вход данные, выполняет ряд процедур(функции), и выводится результат
// сначала все программы писались по этому программированию, но потом программы начали расширяться и придумали ооп


// клас является описанием характеристики, а объект это конкретный эксемпляр, которого каждая харантеристика имеет значение

// к примеру есть человек. его имя, фамилия, возвраст - это свойства
// его действия (ходить, прыгать, бегать) являются методами

class Rectangle {
    width;
    height;

    constructor(w, h) {
        this.width = w;
        this.height = h;
    }

    calcArea() {
        return this.width * this.height;
    }
}

// объект это любой экземпляр какого-либо класса
// тут мы создали объект
const rect = new Rectangle(5, 10)
rect.calcArea();


// ооп построено на двух основных принципах инкапсуляция, наследование, полиформизм

// инкапсуляция и сокрытие. суть инкапсуляции говорит о том что, что сам класс является как капсулой
// которая содержит свойства и методы. она позволяет их объеденить
class User{
    private _username;
    private _password;
    private _id;

    constructor(username, password) {
        this._username = username;
        this._password = password;
        this._id = Math.random();
    }
    get username() {
        return this._username
    }
    set username(value) {
        this._username = value;
    }
    get password() {
        return this._password;
    }
    set passwor(value) {
        this._password = value;
    }
}




// наследование
// у нас есть клас человек который имеет свойства(имя, возвраст, фамилия)
// и у нас появляется клас работник, который имеет те же данные, но у него появляются данный который нужны работадателю
// клас работник расширяет клас человек
// двигаясь по цепочке, у нас появляется клас разработчик, который наследует те же данные, но тем самым добавляет еще, те который нужны для разработки
// программ, язык программирования, уровень, номер команды

// c помощью наследования мы можем создавать целую иерархию классов
class Person {
    private name;
    private surname;
    private age;

    constructor(name, surname, age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }

}


// можно унаследоваться только от одного класса, кроме с++
class Employee extends Person {
    private inn;
    private number;
    private snils;

    constructor(name, surname, age, inn, number, snils) {

        // супер означает что сначала будет выведен родительский конструктор
        super(name, surname, age);
        this.inn = inn;
        this.number = number;
        this.snils = snils;
    }
}

const employee = new Employee("vlad", "chekh", 123, 231, 321, 321);


class Developer extends Employee {
    private level;

    constructor(name, surname, age, inn, number, snils, level) {
        super(name, surname, age, inn, number, snils );
        this.level = level;
    }
}

// cоздаем экземпляр
const vladProg = new Developer("vlad", "chekh", 123, 231, 321, 321, "middle");



// полиморфизм = с перевода имеет много форм
// он делится на параметрический(истинный) и ad-hoc(мнимый)


// мнимый

class Calculator {
   // add(a: number, b:number):number {

        //return a + b;
    }
   // add(a: string, b: string): string {
      //  return a + b;
   // }
//}

//add(5, 5) // 10
//add("5", "5")  // 55



// параметрический

class Person1 {
    private _name;
    private _lastname;
    private _age;

    constructor(_name, _lastname, age){
        this._name = _name;
        this._lastname = _lastname;
      //  this._age = _age;
    }
}





// агрегация - процесс объединения элементов в одну систем

// ассоциация - это такой тип при котором объекты будут ссылаться друг на друга. При этом они остаются полностью независимыми друг от друга.

// агрегация -  это тип отношений когда один объект является частью другого. Агрегация образует слабую связь между объектами. Все зависимые классы инициализируются вне основного объекта.

// композиция - это тип отношений при котором один объект может принадлежать только другому объекту и никому другому. При композиции образуется сильная связь между объектами. При таком типе отношений основной объект полностью обеспечивает жизненный цикл объектов от которых он зависит. Используем еще один пример из реальной жизни. Возьмем машину и двигатель. Машина и двигатель конечно могут существовать друг без друга, но суть не в этом. А в том что при конкретной реализации рабочей машины, один двигатель может принадлежать только одной машине, поэтому для такой связи логично использовать композицию.




// авбстрактные классы и интерфейсы

// интерфейсы - в нем описаны некоторые методы какого они параметра, что они возвращают
// но при этом нет реализации, интерфейс это как оглавление в учебнике, он говорит что сделать, но не говорит как
// нельзя создать объект

// абстрактные классы - похожи, в абстрактных классах тоже нет реализации, но в них можно создавать методы с какой-то реализацией,
// от них можно унаследовать

// в первую очередь систему нужно проектировать на уровне интерфейсов

// мы должны под интерфейсы уже реализовать класы

class User1 {
    username: string;
    age: number;
}

interface Repository<T>{
    create: (obj: T) => T;
    get: ()=> T;
    delete: (obj: T) => T;
    update: (obj: T) => T;
}

// нельзя создать объект

//class UserRepo implements Repository<User> {
   // create(user: User):void {

    //}
  //  delete(): void {

   // }
 //   get(): void {

  //  }
    //update(): void {

   // }
//}



// комбинируя все принципы, которые тут есть, на этом фундаменте можно построить принцип солид и различное количество патернов





// реализация паттерна dependency injection - внедрение зависимостей


// в зависимости от условий мы выбираем ту или иную базу данных
// слой 1. работа с базой данных. два подвида mongorepository and mysqlrepository

// слой 2. бизнес- логика